
_ENV = mkmodule("first_landing_libs_random_names")

local random = require "libs_random"

-- Generate an order 2 Markov chain frequency table from the given text.
function mktable(text)
	local a, b, c = 1, 2, 3
	if text:len() <= 2 then
		return nil
	end
	local tbl = {}
	repeat
		local key = string.char(text:byte(a), text:byte(b))
		if tbl[key] == nil then
			tbl[key] = {}
		end
		table.insert(tbl[key], string.char(text:byte(c)))
		
		a, b, c = b, c, c + 1
	until c > text:len()
	return tbl
end

-- A bunch of names from Greek mythology, end to end with no spaces. Seems like a good sample...
table_greek = mktable("aphroditehephaestusaresapolloartemiszeusletoheraathenademetercronuspersephonedionysushadeshermeshestiaposeidonaetheranankeereboserebusgaiagaeahemerachronosnesoinyxuranusoureaphanespontustartarusthalassahyperioniapetuscoeuscriuscronusoceanusphoeberheatethytheiathemisasteriaastraeusatlasauradioneeosepimetheuseurybiaeurynomehelioslelantosmenoetiusmetisophionpallaspersesprometheusselenestyxagriusantaeusargustalosorionadikiaaergiaagonaidosalalalyssalethehypnoskratoslimoslyssaamechaniapalioxisdoloscaeruscoruspeithopersephonehecatetheseusacheilosamphitriteneristesproteustritonnereidesgaleneboreaseurusnotuszephyrusouranosastraiosastralosadoniscarmedesponiaplutusheraclesantheiameletearchecharitesauxesiaeleusishectorminoschrysippusdiomedesargosajaxachillesabderusaeneasorpheusganymedeeuropahelenmedusapandorahelenusgelanorhaemusabashippothonmidasorestesceleuspelias")

-- This one has the spaces left in, just in case you don't mind having spaces in your names.
-- If you use this sample keep in mind that it creates a sparser table, so you get less consistent results (but they
-- may be more pronounceable).
table_greek2 = mktable("aphrodite hephaestus ares apollo artemis zeus leto hera athena demeter cronus persephone dionysus hades hermes hestia poseidon aether ananke erebos erebus gaia gaea hemera chronos nesoi nyx uranus ourea phanes pontus tartarus thalassa hyperion iapetus coeus crius cronus oceanus phoebe rhea tethy theia themis asteria astraeus atlas aura dione eos epimetheus eurybia eurynome helios lelantos menoetius metis ophion pallas perses prometheus selene styx agrius antaeus argus talos orion adikia aergia agon aidos alala lyssa lethe hypnos kratos limos lyssa amechania palioxis dolos caerus corus peitho persephone hecate theseus acheilos amphitrite neristes proteus triton nereides galene boreas eurus notus zephyrus ouranos astraios astralos adonis carme desponia plutus heracles antheia melete arche charites auxesia eleusis hector minos chrysippus diomedes argos ajax achilles abderus aeneas orpheus ganymede europa helen medusa pandora helenus gelanor haemus abas hippothon midas orestes celeus pelias")

-- Generate a string of the given length (or shorter) from an order 2 Markov chain table.
-- 
-- The result may be shorter than requested if the generator runs into a case where there are no defined transitions. If
-- the returned results tend to be too short then try increasing your sample size when generating the table (increasing
-- maxlen will have no effect if the table is too sparse).
-- 
-- Leading and trailing whitespace (if any) is stripped before return.
-- 
-- Example:
--	rnames.generate(5, table_greek)
function generate(maxlen, tbl)
	local name = random.select(tbl, true)
	local a, b = string.char(name:byte(1)), string.char(name:byte(2))
	local clen = 2
	
	repeat
		char = random.select(tbl[a..b])
		if char == nil then
			-- Oops, we have no entries for this key!
			-- let's take the easy way out and just return a shorter result.
			return name
		end
		name = name..char
		
		a, b = b, char
		clen = clen + 1
	until clen >= maxlen
	
	return string.trimspace(name)
end

-- Returns the possessive form of every possible settler first name.
local function names()
	local items = {}
	for _, name in ipairs{
		-- This list was generated by a custom Lua script.
		-- It was a major pain in the ass, so I don't ever want to do it again...
		"thimeth", "nithros", "namar", "idil", "ono", "ari", "mater", "escu", "angir",
		"rud", "shud", "penoc", "leto", "eggu", "durpul", "uvno", "tal", "ongu", "curo",
		"irnat", " wlist", "ori", "athod", "lomam", "uzin", "othdo", "isi", "innah", "as",
		"anri", "ebdi", "heju", "rirdest", "thora", "ves", "uthret", "aril", "olo", "rilstud",
		"pilat", "hibor", "subi", "thakom", "doto", "das", "erod", "ramkal", "us", "hok", "uja",
		"jol", "tequil", "cango", "olith", "ricdil", "shem", "segok", "mesm", "gel", "gosath",
		"abe", "ki¤ ", "cil", "¤ita", "utdar", "ngethac", "pobe", "dem", "emeg", "pis", "lum",
		"stalcon", "obin", "nek", "sekur", "thrathdad", "dilol", "gulo", "coni", "osp", "pan",
		"konli", "perom", "kadest", "asseg", "abli", "ago", "renal", "mekgos", "jepum", "kothvir",
		"zobsha", "kopoh", "atlel", "ithru", "vispol", "githa", "ilre", "rigu", "tumwist", "mudi",
		"lomoth", "threbe", "rura", "asi", "itvid", "ersi", "udal", "semod", "quab", "kanil", "gisu",
		"ricgo", "etru", "gogol", "apug", "ulco", "somlis", "batow", "co¤u", "fat b", "tekud", "dolak",
		"¤ethu", "thrura", "mim", "udi", "jonic", "bote", "kortil", "pidud", "ur", "r kfil", "gugir",
		"anir", "katslet", "tunul", "bini", "sothbod", "iguk", "kir", "strohe", "bora", "gatshi",
		"setoc", "oti", "nganiz", "belza", "eno", "sathar", "pamnot", "quazo", "imo", "kamde",
		"palath", "sinur", "komo", "meben", "islas", "seba", "ebe", "specut", "amak", "quenir",
		"adu", "nithim", "moto", "thothil", "thil", "ivak", "cemir", "bemta", "edri", "hathur", "ecod",
	} do
		last = name:sub(-1)
		if last == "s" then
			table.insert(items, name.."'")
		else
			table.insert(items, name.."'s")
		end
	end
	return table.unpack(items)
end

-- This needs LOTS more words before it can be used as the effective basis for a creature name generator.
local wordlists = {
	["Predatory"] = {
		noun = {
			"ripper",
			"claw",
			"fang",
			"cat",
			"bear",
			"wolf",
			"raptor",
		},
		adj = {
			"dire",
			"death",
			"ripper",
			"claw",
			"fang",
			"shredder",
		},
	},
	["Grazer"] = {
		noun = {
			"wanderer",
			"roamer",
			"cow",
			"deer",
			"ox",
		},
		adj = {
			"wandering",
			"roaming",
		},
	},
	["Flier"] = {
		noun = {
			"soarer",
			"bird",
			"bat",
		},
		adj = {
			"swooping",
			"soaring",
			"cloud",
		},
	},
	["Large"] = {
		noun = {
			"mammoth",
			"gargantuan",
		},
		adj = {
			"giant",
			"great",
			"grand",
			"mammoth",
			"gargantuan",
			"greater",
		},
	},
	["Small"] = {
		noun = {
			"chipmunk",
			"squirrel",
			"dog",
			"cat",
		},
		adj = {
			"lesser",
			"minor",
		},
	},
	["Furry"] = {
		noun = {
		},
		adj = {
			"hairy",
			"furry",
			"ruffed",
			"maned",
			"long-haired",
		},
	},
	["Leathery"] = {
		noun = {
		},
		adj = {
			"leathery",
			"naked",
			"hairless",
		},
	},
	["Scaly"] = {
		noun = {
			"lizard",
		},
		adj = {
			"scaly",
			"scaled",
			"plated",
			"armored",
		},
	},
	["Fishy"] = {
		noun = {
			"fish",
			"trout",
			"eel",
			"pike",
		},
		adj = {
		},
	},
	["Generic"] = {
		noun = {
			"beast",
			"monster",
		},
		adj = {
			"common",
			"uncommon",
			names() -- This expands to the possessive form of every possible settler first name.
		},
	},
}

local validflags = {
	"Predatory",
	"Grazer",
	"Flier",
	"Large",
	"Small",
	"Furry",
	"Leathery",
	"Scaly",
	"Fishy",
	"Generic",
}

function generate_animal(flags)
	if rubble.configvar("FL_ADV_RANDOM_NAMES") == "NO" then
		return generate(random.range(4, 10), table_greek)
	end
	
	flags.Generic = true
	
	local adj, noun = {}, {}
	for _, flag in ipairs(validflags) do
		if flags[flag] then
			for _, word in ipairs(wordlists[flag].noun) do
				table.insert(noun, word)
			end
			for _, word in ipairs(wordlists[flag].adj) do
				table.insert(adj, word)
			end
		end
	end
	return random.select(adj).." "..random.select(noun)
end

return _ENV
